import threading
import select
import subprocess
import alsaaudio
import socket
import pynotify

import gtk
from daemon import Daemon as d
import time
import sys
import traceback

import gobject
import gtk
import appindicator

import subprocess

import logging
logging.basicConfig(filename='audiojackermsgs.log',level=logging.DEBUG)

#volume
currVolume = 0

#
#Class listens for audiojack events
class AudioJackEventHandler(object):
        def __init__(self):
                self.subscribers = []
        def subscribe(self,somefunction):
                self.subscribers.append(somefunction)
        def unsubscribe(self,somefunction):
                self.subscribers.remove(somefunction)
        def start(self):
                t = threading.Thread(target=self.reallystart)
                t.daemon = True
                t.start()
        def reallystart(self):
                process = subprocess.Popen('acpi_listen', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		while True:
			#the items to be read by process
			reads = [process.stderr.fileno(), process.stdout.fileno()]
			returned = select.select(reads, [], [])
			for readydata in returned[0]:
				if (readydata == process.stdout.fileno()):
					self.notify(process.stdout.readline())
				#if (readydata == process.stderr.fileno()):
				#	print("stderr says {}".format(process.stderr.readline()))
        def notify(self,someevent):
                for sub in self.subscribers:
                        sub(someevent)
#
#Class listens for .. events
class ComputerStateEventHandler(object):
        def __init__(self):
                self.subscribers = []
                self.s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                self.s.connect("/var/run/acpid.socket")
        def subscribe(self,somefunction):
                self.subscribers.append(somefunction)
        def unsubscribe(self,somefunction):
                self.subscribers.remove(somefunction)
        def start(self):
                t = threading.Thread(target=self.reallystart)
                t.daemon = True
                t.start()
        def reallystart(self):
                while 1:
                    for event in self.s.recv(4096).split('\n'):
                        event=event.split(' ')
                        if len(event)<2: continue
                        if event[0]=='button/lid':
                            if event[2]=='open':
                                self.notify('lid open')
                            elif event[2]=='close':
                                self.notify('lid closed')
        def notify(self,someevent):
                for sub in self.subscribers:
                        sub(someevent)

#
#method for running commands
def runcmd(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    out, err = p.communicate()
    return (out,err)
#
#method for retrieving current sound level
def getsoundlevel():
        out, err = runcmd('echo `(pactl list sinks | grep "Volume: 0:")| awk \'{print $3}\'`')
        return out
def setsoundlevel(volume):
        out,err = runcmd('pactl set-sink-volume 0 {}'.format(volume))

#method to be called with the events generated by audio jack
def audiojackresponder(someeventstring):
        global currVolume

        tmpvolume = getsoundlevel()
        if tmpvolume!="0%":
            currVolume = tmpvolume

        someeventstring = someeventstring.rstrip()
        if (someeventstring=="jack/headphone HEADPHONE unplug"):
                print('audiojackresponder1.5: current volume is {}'.format(currVolume))
                setsoundlevel('0%')
        elif (someeventstring=="jack/headphone HEADPHONE plug"):
                print('set sound back')
                setsoundlevel(currVolume)
        elif (someeventstring.startswith("button/mute MUTE")):
                print('mute pressed')
        print('audiojackresponder2: current volume is {}'.format(currVolume))


# method for changing audio state back to what it was
def changestate_cb(n, action):
        assert action == "ignore"
        setsoundlevel(currVolume)
        gtk.main_quit()
def donotchangestate_cb(n, action):
        assert action == "ignore"
        gtk.main_quit()
#method to be called with the events of the computer lid
def computerlidresponder(someeventstring):
        if (someeventstring=='lid closed'):
                setsoundlevel('0%')
        elif (someeventstring=='lid open'):
                logging.debug('lid open response called!')

                title = "audiojacker"
                msg = "Audio was open muted on lid close. unmute?"
                pynotify.init(title)
                notif = pynotify.Notification(title, msg, )
                notif.set_urgency(pynotify.URGENCY_CRITICAL)
                notif.add_action("ignore","No", donotchangestate_cb)
                notif.add_action("ignore","Yes", changestate_cb)
                notif.show()
                gtk.main()
#
#AudioJack daemon
class AudioJack(d):
        def run(self):

                ajeh = AudioJackEventHandler()
                ajeh.subscribe(audiojackresponder)
                ajeh.start()

                global currVolume
                currVolume = getsoundlevel()

                cseh = ComputerStateEventHandler()
                cseh.subscribe(computerlidresponder)
                cseh.start()

                while True:
                        pass

if __name__=='__main__':
        daemonaudiojack = AudioJack('/tmp/audiojacker.pid')
        if len(sys.argv) == 2:
                if 'start' == sys.argv[1]:
                        daemonaudiojack.start()
                elif 'stop' == sys.argv[1]:
                        daemonaudiojack.stop()
                elif 'restart' == sys.argv[1]:
                        daemonaudiojack.restart()
                else:
                        print "Unknown command"
                        sys.exit(2)
                sys.exit(0)
        else:
                print "usage: %s start|stop|restart" % sys.argv[0]
                sys.exit(2)
